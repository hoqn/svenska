---
title: "시네마 서울"
stacks:
  - TypeScript
  - React
  - Vite
start_date: 2023. 04.
end_date: 2023. 06.
icon: "🎞"
links:
  "소스코드(FE)": "https://github.com/Cinema-Seoul/cine-seoul-fe"
  "소스코드(BE)": "https://github.com/cinema-Seoul/cine-seoul-be"
---

> [!note] 정보
>
> - BE 소스코드: https://github.com/cinema-Seoul/cine-seoul-be
> - FE 소스코드: https://github.com/cinema-Seoul/cine-seoul-fe
>
>   제가 맡은 파트는 FE예요.

학부 전공 과목 중 설계 과목으로 *데이터베이스설계및실습*이란 과목을 수강하게 되었다. 이름 그대로 데이터베이스를 설계하고 이를 활용한 실습을 해보는 과목이다. 상황은 과목에서 제시되었고, 이를 해결하는 서비스를 개발하는 것이 과제였다.

# 1. 프로젝트 소개

본 프로젝트에서는 여러 개의 상영관을 가진 멀티플렉스 영화관의 인터넷 영화예매 시스템을 구축하기 위한 데이터베이스를 설계하고, 이 데이터베이스 위에서 동작하는 응용 프로그램을 개발한다.

> 서울시네마는 전체 2,100석의 좌석을 보유하고 있고, 8개의 상영관을 가지고 있으며 각 상영관마다 하루 평균 6회의 영화를 상영 중에 있다. 좋은 위치와 멀티플렉스라는 장점으로 독점을 하였으나 최근 XX에 멀티플렉스 영화관이 속속 생겨나면서 경쟁을 하고 있다.

## 1.1. 시스템 구축 방향

- 현재 티켓링크와 맥스무비의 예매 시스템 분석
- 인터넷 결제를 통한 영화표 예매
- 데이터베이스 기반의 관리 시스템 구축

# 2. 계획

## 2.1. 환경

#### 필수 사항

- 오라클 DBMS 사용 必

#### 개발 환경

- 웹 백엔드: `Java`, `Spring Boot`, `Oracle`
- **웹 프런트엔드**: `TypeScript` `React` `Vite` `react-router-dom`
  - 스타일링: `unocss`, `@radix-ui/colors`
  - 애니메이션: `framer-motion`
  - 전역 상태: `zustand`
- 문서 관리: Google Spreadsheet, Notion, ERDCloud

## 2.2. 역할과 책임

- 웹 백엔드 개발: 2명
- 웹 프런트엔드 개발: **1명** ← 내가 맡은 부분
- 데이터베이스 설계 및 산출물 작성: **3명** 모두

개발 부분에서 나는 프런트엔드 개발을 혼자 맡게 되었다.

또한 문서를 다루는 데 내가 제일 익숙하여 산출물 양식을 Google Spreadsheet에 구현하고 관리하는 일도 담당하였다. 공유 문서를 적극적으로 활용해 산출물 양이 많음에도 원활한 작업이 가능했다.

데이터베이스설계 과목을 수강하며 진행한 프로젝트인 만큼, 데이터베이스의 설계도 3명 모두 함께 진행하였다. 주로 대면으로 직접 만나 데이터베이스 설계 원칙이나 개인 의견을 근거로 더 나은 데이터베이스 설계를 위해 노력했다.

# 3. 결과물

## 3.1. 데이터베이스 설계

데이터베이스 설계는 3명이 모두 함께 진행하였다.

![시네마서울.png](./cinema-seoul/38b1f36ec43900e0f1d146f32911c74e9148a7b9.png)

ERD를 여러 번에 걸쳐 회의하고, 또 수정했다. 적절한 관계를 설정하고, 또 필요한 데이터들을 정했다.

![](./cinema-seoul/2023-11-10-17-24-44-image.png)

더불어서, 필요한 산출물들도 Google Spreadsheets를 활용해 작성하였다.

## 3.2. 인터페이스 설계

인터페이스 설계는 프론트엔트를 맡은 내가 담당하였다. 피그마를 사용해 기본적인 부분만 빠르게 설계하였다.

## 3.3. 웹 프런트엔드 개발 결과

### 3.3.1. 영화 목록 및 세부 정보

![](./cinema-seoul/2023-11-10-17-31-13-image.png)

![](./cinema-seoul/2023-11-10-17-31-41-image.png)

![](./cinema-seoul/2023-11-10-17-32-10-image.png)

![](./cinema-seoul/2023-11-10-17-32-30-image.png)

![](./cinema-seoul/2023-11-10-17-32-53-image.png)

### 3.3.2. 영화 예매

예매 상태는 zustand 전역 상태로 관리하였다.

![](./cinema-seoul/2023-11-10-17-34-29-image.png)![](./cinema-seoul/2023-11-10-17-33-26-image.png)![](./cinema-seoul/2023-11-10-17-34-16-image.png)

### 3.3.3. 관리자 페이지

관리자 페이지는 별도의 라우팅(`/admin/*`)으로 구성했고, 사용하는 환경이 완전히 다르기 때문에 관리자 페이지와 고객용 페이지는 각각 `lazy import`를 사용해 사용하지 않는 부분의 라우팅 소스는 다운 받지 않도록 하였다.

![](./cinema-seoul/2023-11-10-17-35-06-image.png)

# 4. 회고 및 배운 점

## 4.1. 성과

이번 프로젝트는 성공적으로 목표를 달성하였다. 담당 교수님께 좋은 평가를 받음과 동시에, 평점에서도 좋은 점수를 받을 수 있었다.

또한 프런트엔드 개발을 혼자 맡아 했기 때문에 걱정이 다소 있었는데, 팀 내에서도 프런트엔드 개발 결과물에 대해 좋은 평가를 받을 수 있었다 :\)

## 4.2. 그럼에도 아쉬운 점

### 4.2.1. SPA로 구현했다는 아쉬움

개인적으로 이번 프로젝트는 웹 사이트의 성격이 강한 탓에 `Next.js`를 이용해 SSR에 기반한 MPA로 구현하고 싶었지만, 개발 일정이 예상보다 짧아져 `react-router-dom`만을 이용해 SPA로 구현하였다. 최소한 관리자 페이지와 고객 페이지는 완전히 별개이기 때문에 따로 lazy 로딩 처리를 해주었다는 점에서 만족해야 했다 :\(

이후 맡는 프로젝트에선 `Next.js`, 그 중에서도 많은 부분이 바뀌었지만 아직 낯선 13버전을 적극적으로 활용하고 싶어져 이번 프로젝트가 끝난 뒤 공부를 더 해볼 생각이다.

### 4.2.2. Form validation을 미련하게 구현했다는 생각

`react-hook-form`이라는 좋은 라이브러리가 있다는 것은 이미 알고 있었다. 하지만 익숙지 않아서인지, 괜한 자존심인 건지 Form validation 관련한 훅을 직접 만들었다. 미련한 짓일지도 모르겠지만, 그 과정에서 재미있기는 했다. 아래가 내가 직접 구현했던 Form validation 훅을 사용한 컴포넌트이다!

![](./cinema-seoul/2023-11-11-14-09-51-image.png)

직접 구현해본 경험은 좋았지만, 완성도 측면에서는 `react-hook-form`과 같은 검증되고 훌륭한 라이브러리를 사용하는 것이 더 나을 것 같다. 다음에는 꼭 사용해보려 한다.

바퀴를 다시 발명하지 말라고 하지만, 한 번 쯤은 그 동작원리를 파악하고 쓰는 이유를 체감하기 위해선 무식할지라도 직접 구현해보는 것도 좋은 방법인 것 같다.

## 4.3. 트러블슈팅 & 고민

### 4.3.1. Context vs. 전역 상태

앱 전체를 관통하거나 계속 유지되어야 하는 상태들은 전역 상태에서 관리하는 게 마땅할 것이다. 하지만, 이 범주에 들어가지 않는 경우는 Redux나 Zustand와 같은 전역 상태를 사용하는 것이 나은가, Context를 사용하는 것이 나은가 고민이 많이 되었다.

나는 원래 Context를 많이 애용하는 편이었다. 하지만 현실적으로 전역 상태를 사용하는 것이 더 효율적일 때도 많았다. 예컨대, 이번 프로젝트에서 예매 과정은 예매 페이지를 벗어나도 유지되어야 사용자 경험 상 유리하다. 이를 위해 더 높은 컴포넌트에 Context를 위치시킬 수 있지만, 이런 경우 결국 더 강하게 종속되고 말 것이다. 이런 경우 오히려 전역 상태로 관리하는 것이 더 독립적이게 구현할 수 있을 것이다.

이번 프로젝트에선 전역 상태를 더 적극적으로 활용했다. 어차피 Redux와 같은 라이브러리도 상태 관리의 책임을 Redux에서 질 뿐, 컴포넌트에 제공하는 것은 Context API를 통해서이다. 정말로 특정 컴포넌트 하위에서만 쓰이고 UI와 더 긴밀한 사례에만 Context를 직접 사용하기로 했다.

이번에 느낀 것은, 생각보다도 내가 전역 상태를 사용하지 않았다는 것이다. 계속 사용될 값이고, UI를 벗어나 비즈니스 로직을 관통하는 데이터라면 오히려 전역 상태로 관리하는 것이 옳지 않을까 생각하게 되었다. Context는 prop-drilling을 막는 정도로만 사용해도 충분할 거라 생각이 바뀌었다.

### 4.3.2. unocss(tailwindcss) 플러그인 작성

이번 프로젝트는 tailwindcss와 매우 유사한 unocss를 사용했다. tailwindcss보다 transformer나 preset 등을 작성하기 더 수월할 것 같아 선택하였다. 실제로 개발하면서 필요한 하나의 프리셋과 하나의 트랜스포머를 작성해 사용하였다.

#### `unocss-multi-state-values`

어떤 방법으로든 스타일 코드를 작성하다 보면, `hover`-`active`-`disabled` 같은 상태들마다 다른 값을 가질 때가 있다. 이럴 때 코드가 상당히 길어지기도 한다. 예컨대, 마우스 상태에 따라 배경색이 바뀌어야 할 때는 `bg-red-100 hover:bg-red-200 active:bg-red-300`이라 작성해야 한다.

이 경우의 편의를 위해 설정에서 미리 `{{*}}` 규칙은 `기본값:hover:active` 라는 식으로 기입해두면 `bg-red-{{100:200:300}}` 로 작성할 수 있으면 편하겠다는 생각으로, 구현하였다.

하지만 아쉽게도 많이 쓰이지 못해 결과적으로는 설정에서 제거하였다. 이미 사용되고 있던 `variant-group`과 섞어 쓰기 난해하여 오히려 더 복잡해지기도 한 것이 큰 이유였다. :\( `variant-group`은 `active:bg-black active:text-white`으로 작성하는 것을 `active:(bg-black text-white)`와 같이 작성할 수 있도록 해주는 트랜스포머이다. 또한 일반적이지 않고 설정 파일에 과도하게 의존된 코드가 작성되는 느낌이 들었다는 점도 제거하는 데 이유가 되었다.

(코드)[https://github.com/Cinema-Seoul/cine-seoul-fe/blob/master/lib/unocss-multi-state-values.ts]

### 4.3.3. React에서의 Modal 표현

이 부분은 React 프로젝트를 진행할 때마다 고민한다. 네이티브 앱들과 달리, 웹에서는 `alert` (+ 팝업)를 제외하면 브라우저에서 Modal이 별도로 지원되지 않는다. 따라서 DOM 상에서 직접 구현해줘야 한다. 이렇다보니 React에서의 Modal도 결국 상태 등을 통해 토글해줘야 한다.

이때 나는 두 가지 고민을 했다. 서로 다른 모달들을 따로 구현하는 게 맞을까, 하나의 모달로 구현하되 내부의 컨텐츠만 변경하는 게 맞을까?

당연히 후자가 더 효율적으로 보였다. 이를 구현하기 위해서 나는 Modal만을 위한 Context에 내부 컨텐츠 노드를 저장하고, 호출할 때 이를 변경하는 식으로 구현해보았다.

```ts
export function useModal() {
  const context = useContext(ModalContext);

  const showModal = useCallback(
    (element: ReactNode) => {
      context.setElement(element);
      context.setShowing(true);
      console.log("modal open");
    },
    [context],
  );

  const closeModal = useCallback(() => {
    context.setElement(null);
    context.setShowing(false);
    console.log("modal closed");
  }, [context]);

  return {
    showModal,
    closeModal,
  } as const;
}
```

이런 식의 구현은 다소 걱정되는 부분이 있다. Context에 노드 자체를 저장하고, 노드를 state로 관리한다는 점에서 퍼포먼스적인 측면에서 문제가 있지 않을까 걱정됐다. 시간이 촉박해 수치적인 분석은 하지 못하고 실험적으로 사용해봤을 때 문제가 발견되지 않아 이번 프로젝트에서는 이런 구조를 사용해보았다.

추후 찾아본 바로는, 컴포넌트를 state로 관리하는 것은 조금 위험할 수 있다는 말이 많았다. ([참고](https://stackoverflow.com/questions/66919014/is-it-a-good-idea-to-store-components-in-state)) 사실 나도 컴포넌트를 state로 저장하는 것이 걱정되었는데, 역시나였던 것이다.

컨텐츠 컴포넌트를 State로 관리하게 되면 변경 내용을 추적하게 되므로 컴포넌트와 같은 복잡한 Object를 저장하면 성능 측면에서의 손해가 크다.

그렇다면 DOM에 직접 삽입하는 것은 어떨까? 결국 Portal이다. 보통 Modal마다 따로 컴포넌트를 만들 때 Portal을 많이 사용하는 것 같다. 나도 그러했다. 하지만 이번 경우에선 Portal을 컨텐츠 컴포넌트에 적용하지 않은 것은 결국 호출하는 쪽에서 렌더링을 시켜줘야 한다는 점이었다. 나는 함수만 호출하듯이 Modal을 관리하는 것을 원했다...

이 부분은 더 많은 고민을 해보려 한다.
